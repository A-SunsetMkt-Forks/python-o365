import logging
import json
import os
from pathlib import Path

import requests
from oauthlib.oauth2 import TokenExpiredError
from requests_oauthlib import OAuth2Session

log = logging.getLogger(__name__)

O365_API_VERSION = 'v1.0'


class BaseApi(object):
    _endpoint_url = 'https://graph.microsoft.com/{api_version}/{resource}'

    def __init__(self, api_version=O365_API_VERSION, main_resource='me', **kwargs):
        self.api_version = api_version
        self.main_resource = main_resource
        self.endpoint = self._endpoint_url.format(api_version=self.api_version, resource=main_resource)

    def _build_url(self, resource):
        return '{endpoint}{resource}'.format(endpoint=self.endpoint, resource=resource)


class Connection(object):
    _oauth2_authorize_url = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize'
    _oauth2_token_url = 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
    _default_token_file = 'o365_token.txt'
    _default_token_path = Path() / _default_token_file
    _allowed_methods = ['get', 'post', 'put', 'patch', 'delete']

    def __init__(self, username=None, password=None, client_id=None, client_secret=None, proxy_server=None,
                 proxy_port=8080, proxy_username=None, proxy_password=None, api_version='v1.0'):
        """ Creates a O365 connection object
        :param username: basic auth: username to login with
        :param password: basic auth: password for authentication
        :param client_id: oauth2: application_id generated by https://apps.dev.microsoft.com when you register your app
        :param client_secret: oauth2: secret password key generated for your application
        """
        assert (username and password) or (client_id and client_secret), 'Provide valid auth credentials'
        if username and password:
            self.auth_method = 'basic'
            self.auth = (username, password)
        else:
            self.auth_method = 'oauth'
            self.auth = (client_id, client_secret)

        self.api_version = api_version

        self.proxy = None
        self.set_proxy(proxy_server, proxy_port, proxy_username, proxy_password)

        self.oauth = None
        self.store_token = True
        self.token = None

    def set_proxy(self, proxy_server, proxy_port, proxy_username, proxy_password):
        """ Sets a proxy on the Session """
        if proxy_server and proxy_port and proxy_username and proxy_password:
            self.proxy = {
                "http": "http://{}:{}@{}:{}".format(proxy_username, proxy_password, proxy_server, proxy_port),
                "https": "https://{}:{}@{}:{}".format(proxy_username, proxy_password, proxy_server, proxy_port),
            }

    def oauth2(self, store_token=None, token_path=None, scope=None):
        """ Connect to office 365 using specified Open Authentication protocol

        :param store_token: whether or not to store the token in file system,
                            so u don't have to keep opening the auth link and authenticating every time
        :param token_path: full path to where the token should be saved to
        :param scope: a list of scopes that your app has access to
        """

        if store_token is None:
            store_token = self.store_token
        else:
            self.store_token = store_token

        client_id, client_secret = self.auth

        self.token = token = self._load_token(token_path)

        if not scope:
            scope = ['https://graph.microsoft.com/Mail.ReadWrite',
                     'https://graph.microsoft.com/Mail.Send',
                     'offline_access']

        if not token:
            self.oauth = ouath = OAuth2Session(client_id=client_id,
                                               redirect_uri='https://outlook.office365.com/owa/',
                                               scope=scope)

            auth_url, state = ouath.authorization_url(url=self._oauth2_authorize_url, access_type='offline')
            print('Please open {} and authorize the application'.format(auth_url))
            auth_resp = input('Enter the full result url: ')

            # Allow token scope to not match requested scope. (Other auth libraries allow
            # this, but Requests-OAuthlib raises exception on scope mismatch by default.)
            os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = '1'
            os.environ['OAUTHLIB_IGNORE_SCOPE_CHANGE'] = '1'

            self.token = token = ouath.fetch_token(token_url=self._oauth2_token_url, authorization_response=auth_resp,
                                                   client_secret=client_secret, proxies=self.proxy)

            if store_token:
                self._save_token(token, token_path)
        else:
            self.oauth = OAuth2Session(client_id=client_id, token=token)

    def refresh_token(self):
        """ Gets another token """
        client_id, client_secret = self.auth
        self.token = token = self.oauth.refresh_token(self._oauth2_token_url, client_id=client_id,
                                                      client_secret=client_secret, proxies=self.proxy)
        if self.store_token:
            self._save_token(token)

    def request(self, url, method, **kwargs):
        """ Makes a request
        :param url: the requested url
        :param method: method to use
        """

        method = method.lower()
        assert method in self._allowed_methods, 'Method must be one of the allowed ones'

        if method == 'get':
            kwargs.setdefault('allow_redirects', True)
        elif method in ['post', 'put', 'patch']:
            if 'headers' not in kwargs:
                kwargs['headers'] = {}
            kwargs['headers']['Content-type'] = 'application/json'

        if self.proxy:
            kwargs['proxies'] = self.proxy

        log.info('Requesting URL: {}'.format(url))

        if self.auth_method == 'basic':
            # basic authentication
            kwargs['auth'] = self.auth
            response = requests.request(method, url, **kwargs)
        else:
            # oauth2 authentication
            if not self.oauth:
                self.oauth2()
            try:
                response = self.oauth.request(method, url, **kwargs)
            except TokenExpiredError:
                log.info('Token is expired, fetching a new token')
                self.refresh_token()
                log.info('New token fetched')
                response = self.oauth.request(method, url, **kwargs)

        log.info('Received response from URL {}'.format(response.url))

        # response_json = response.json()
        # if 'value' not in response_json:
        #     raise RuntimeError('Something went wrong, received an unexpected result \n{}'.format(response_json))
        #
        # response_values = [dict(x) for x in response_json['value']]
        #
        # return response_values

        return response

    def get(self, url, params=None, **kwargs):
        """ Shorthand for self.request(url, 'get') """
        return self.request(url, 'get', params=params, **kwargs)

    def post(self, url, data=None, **kwargs):
        """ Shorthand for self.request(url, 'post') """
        return self.request(url, 'post', data=data, **kwargs)

    def put(self, url, data=None, **kwargs):
        """ Shorthand for self.request(url, 'put') """
        return self.request(url, 'put', data=data, **kwargs)

    def patch(self, url, data=None, **kwargs):
        """ Shorthand for self.request(url, 'patch') """
        return self.request(url, 'patch', data=data, **kwargs)

    def delete(self, url, **kwargs):
        """ Shorthand for self.request(url, 'delete') """
        return self.request(url, 'delete', **kwargs)

    def _save_token(self, token, token_path=None):
        """ Save the specified token dictionary to a specified file path

        :param token: token dictionary returned by the oauth token request
        :param token_path: path to where the files is to be saved
        """
        if not token_path:
            token_path = self._default_token_path

        with open(token_path, 'w') as token_file:
            json.dump(token, token_file, indent=True)

    def _load_token(self, token_path=None):
        """ Load the specified token dictionary from specified file path

        :param token_path: Path object to the file with token information saved
        """
        if not token_path:
            token_path = self._default_token_path
        else:
            if not isinstance(token_path, Path):
                raise ValueError('token_path must be a valid Path from pathlib')

        token = None
        if token_path.exists():
            with open(token_path, 'r') as token_file:
                token = json.load(token_file)
        return token

    def _delete_token(self, token_path=None):
        """ Delete the specified token dictionary from specified file path

        :param token_path: path to where the token is saved
        """
        if not token_path:
            token_path = self._default_token_path
        else:
            if not isinstance(token_path, Path):
                raise ValueError('token_path must be a valid Path from pathlib')

        if token_path.exists():
            token_path.unlink()
